#! /usr/bin/env python

'''
Back up files and encrypt them on the fly if needs be
'''

import sys, os
from os.path import dirname, normpath, expanduser, isfile, getctime, basename
import subprocess
import getpass
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import platform
import yaml

DEVNULL = open(os.devnull, 'w')

def getlatest(path):
    '''
    Return latest ctime in file tree
    '''

    def getfilelatest(latest, filepath):
        '''
        Return latest ctime for file
        '''

        return getctime(filepath) if getctime(filepath) > latest else latest

    latest = 0
    for dirpath, _, filenames in os.walk(path):
        latest = getfilelatest(latest, dirpath)
        for filename in filenames:
            latest = getfilelatest(latest, '%s/%s' % (dirpath, filename))

    return latest

def runbkp(cfg, passphrase, dryrun=False, quiet=False):
    '''
    Run backup
    '''

    dst = expanduser(cfg['destination'])

    # Make destination directory tree
    try:
        os.makedirs(dst)
    except OSError:
        pass

    # Copy files with rsync
    mayrsyncdry = ['-n'] if dryrun else []
    mayrsyncquiet = [] if quiet else ['--progress']
    cmd = ['rsync', '-ar', '--delete', '--files-from=-', '/', dst]
    proc = subprocess.Popen(cmd + mayrsyncdry + mayrsyncquiet,
                            stdin=subprocess.PIPE)
    proc.communicate('\n'.join([normpath(expanduser(path))
                                for path in cfg['copy']]))

    # Options for following commands
    maytarquiet = [] if quiet else ['-v']
    maygpgquiet = ['--batch'] if quiet else []
    stderr = DEVNULL if quiet else None

    # Encrypt
    if 'encrypt' not in cfg:
        return
    for path in cfg['encrypt']:
        npath = normpath(expanduser(path))
        dpath = dirname(npath)
        directory = '%s/%s' % (dst, dpath)
        destination = '%s/%s' % (directory, cfg['encrypt'][path])

        # Does the file need updating?
        if isfile(destination) and getlatest(npath) <= getctime(destination):
            continue

        # Prepare command lines
        tarcmd = ['tar', '-c', basename(npath)]
        gpgcmd = ['gpg', '-c', '-o', destination, '--yes', '--passphrase-fd']
        if not quiet:
            print ' '.join(tarcmd + ['|'] + gpgcmd + ['?'])

        if not dryrun:
            # Make directory tree if needed
            try:
                os.makedirs(directory)
            except OSError:
                pass

            # Write passphrase down a pipe
            rpipe, wpipe = os.pipe()
            os.write(wpipe, passphrase)
            os.close(wpipe)

            # Run processes
            tarproc = subprocess.Popen(tarcmd + maytarquiet,
                                       stdout=subprocess.PIPE,
                                       cwd=dpath)
            # No annoying message on stderr here
            gpgproc = subprocess.Popen(gpgcmd + [str(rpipe)] + maygpgquiet,
                                       stdin=tarproc.stdout)
            gpgproc.communicate()
            tarproc.communicate()
            os.close(rpipe)

def getpassphrase():
    '''
    Ask for passphrase twice, making sure they're identical and not empty
    and return one of them
    '''

    # A la gpg
    pass0 = getpass.getpass("Enter passphrase: ")
    pass1 = getpass.getpass("Repeat passphrase: ")

    if pass0 == pass1 and pass0 != '':
        return pass0

def main():
    '''
    Main routine
    '''

    # Arguments
    description = "Back up files and encrypt them on the fly if needs be"
    parser = ArgumentParser(description=description,
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('collection', metavar='COLLECTION',
                        help="file collection to back up")
    parser.add_argument('--directory', '-d', help="runtime directory",
                        default='~/.bkp', type=expanduser)
    parser.add_argument('--dryrun', '-n', action='store_true')
    parser.add_argument('--quiet', '-q', action='store_true')
    args = parser.parse_args()

    # Load RC file
    try:
        with open(args.directory + '/bkp.yaml') as fhl:
            cfg = yaml.load(fhl, Loader=yaml.BaseLoader)
    except IOError, exc:
        print >> sys.stderr, exc
        return 1

    # Need to ask for a passphrase?
    if 'encrypt' in cfg[args.collection]:
        try:
            passphrase = getpassphrase()
            if not passphrase:
                print >> sys.stderr, "Invalid passphrase"
                return 1
        except KeyboardInterrupt:
            return 1
    else:
        passphrase = None

    # Perform backup
    runbkp(cfg[args.collection], passphrase, args.dryrun, args.quiet)

if __name__ == '__main__':
    sys.exit(main())
