#! /usr/bin/env python

'''
Back up files and encrypt them on the fly if needs be
'''

import sys, os
from os.path import dirname, normpath, expanduser, isfile, getctime
import subprocess
import getpass
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import platform
import yaml

# TODO Make dryrun and verbose independent

def getlatest(path):
    '''
    Return latest ctime in file tree
    '''

    def getfilelatest(latest, filepath):
        '''
        Return latest ctime for file
        '''

        return getctime(filepath) if getctime(filepath) > latest else latest

    latest = 0
    for dirpath, _, filenames in os.walk(path):
        latest = getfilelatest(latest, dirpath)
        for filename in filenames:
            latest = getfilelatest(latest, '%s/%s' % (dirpath, filename))

    return latest

def runbkp(cfg, passphrase, dryrun=False):
    '''
    Run backup
    '''

    src = expanduser(cfg['source'])
    dst = expanduser(cfg['destination'])

    # Make destination directory tree
    try:
        os.makedirs(dst)
    except OSError:
        pass

    # Copy files with rsync
    maydry = ['-n'] if dryrun else []
    cmd = ['rsync', '-ar', '--delete', '--progress', '--files-from=-', src, dst]
    proc = subprocess.Popen(cmd + maydry, stdin=subprocess.PIPE)
    proc.communicate('\n'.join(cfg['copy']))

    # Encrypt
    for path in cfg['encrypt']:
        source = '%s/%s' % (src, path)
        directory = '%s/%s' % (dst, dirname(normpath(path)))
        destination = '%s/%s' % (directory, cfg['encrypt'][path])

        # Does the file need updating?
        if isfile(destination) and getlatest(source) <= getctime(destination):
            continue

        # Prepare command lines
        tarcmd = ['tar', 'c', source]
        gpgcmd = ['gpg', '-c', '-o', destination, '--yes',
                  '--passphrase-fd']

        if dryrun:
            print ' '.join(tarcmd + ['|'] + gpgcmd + ['?'])
        else:
            # Make directory tree if needed
            try:
                os.makedirs(directory)
            except OSError:
                pass

            # Write passphrase down a pipe
            rpipe, wpipe = os.pipe()
            os.write(wpipe, passphrase)
            os.close(wpipe)

            # Run processes
            tarproc = subprocess.Popen(tarcmd, stdout=subprocess.PIPE)
            gpgproc = subprocess.Popen(gpgcmd + [str(rpipe)],
                                       stdin=tarproc.stdout)
            gpgproc.communicate()
            tarproc.communicate()
            os.close(rpipe)

def getpassphrase():
    '''
    Ask for passphrase twice, making sure they're identical and not empty
    and return one of them
    '''

    # A la gpg
    pass0 = getpass.getpass("Enter passphrase: ")
    pass1 = getpass.getpass("Repeat passphrase: ")

    if pass0 == pass1 and pass0 != '':
        return pass0

def main():
    '''
    Main routine
    '''

    # Arguments
    description = "Back up files and encrypt them on the fly if needs be"
    parser = ArgumentParser(description=description,
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('--directory', '-d', help="runtime directory",
                        default='~/.bkp', type=expanduser)
    parser.add_argument('--host', help="host to back up",
                        default=platform.node())
    parser.add_argument('--dryrun', '-n', action='store_true')
    args = parser.parse_args()

    # Load RC file
    try:
        with open(args.directory + '/bkp.yaml') as fhl:
            cfg = yaml.load(fhl, Loader=yaml.BaseLoader)
    except IOError, exc:
        print >> sys.stderr, exc
        return 1

    # Need to ask for a passphrase?
    if 'encrypt' in cfg[args.host]:
        try:
            passphrase = getpassphrase()
            if not passphrase:
                print >> sys.stderr, "Invalid passphrase"
                return 1
        except KeyboardInterrupt:
            return 1
    else:
        passphrase = None

    # Perform backup
    runbkp(cfg[args.host], passphrase, args.dryrun)

if __name__ == '__main__':
    sys.exit(main())
