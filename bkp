#! /usr/bin/env python

import sys, os, os.path
from os.path import expanduser
import subprocess, shlex
import random
import optparse
import tarfile
import getpass
import argparse
import datetime, time
import yaml

# FIXME We should be able to do a single expanduser once and for all

class InvalidPassphraseError(Exception):
    pass

def last(path):
    '''
    Return modification time of last-modified file in expanded path hierarchy
    '''

    maxtime = 0

    def getmaxtime(path, maxtime):
        s = os.stat(path)
        maybemax = s.st_mtime if s.st_mtime > s.st_ctime else s.st_ctime
        return maybemax if maybemax > maxtime else maxtime

    # Root directory
    maxtime = getmaxtime(path, maxtime)

    # Sub hierarchy
    for root, dirs, files in os.walk(path):
        for f in dirs + files:
            maxtime = getmaxtime(root + '/' + f, maxtime)
    return maxtime

def encrypt(path, destfilename, passphrase, now, dryrun=False):
    '''
    Back up by archiving and encrypting on the fly

    Arguments:
    - path to back up
    - destination path
    - passphrase
    - datetime when file has been encrypted and backed up
    - optionally do a dry run
    '''

    cmd = "gpg -c --passphrase-fd 0"
    if dryrun:
        print "tar c '%s' | gpg -c > %s" % (path, destfilename)
    else:
        # Open destination encrypted file
        f = open(destfilename, 'w')

        # Have gpg listen up the pipe
        args  = shlex.split(cmd)
        p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=f)

        # Seems gpg now expects a passphrase, then data down the pipe

        # Write passphrase down the pipe
        print >>p.stdin, passphrase

        # Have tar write data down the pipe
        t = tarfile.open(mode='w|', fileobj=p.stdin)
        t.add(expanduser(path))

        f.close()

def bkp(paths, dest, passphrase, dryrun=False):
    '''
    Perform backup

    Arguments:
    - list of paths to back up
    - destination directory
    - passphrase
    - optionally do a dry run

    Return modified, backed up list of paths 
    '''

    now = time.mktime(datetime.datetime.now().timetuple())

    for path in paths:
        if isinstance(path, str):
            active = True
            filename = None
        elif isinstance(path, dict):
            d = path
            # YAML allows for several keys a dict -- we don't
            if len(d) > 1:
                msg = "More than one key here: %s" % d
                print >>sys.stderr, msg

            for k in d: # Should be only one loop
                # Assume it's to be encrypted
                try:
                    filename = d[k]['filename']
                except KeyError: # So it's not to be encrypted
                    filename = None

                # Assume there's an active key
                try:
                    active = d[k]['active']
                except KeyError: # So there's no active key
                    active = True # Implicitely back up

                path = k
        else:
            print >>sys.stderr, "Came across %s in RC file" % type(path)
            continue

        if active:
            if filename == None: # Don't encrypt
                args = ['rsync', '-aq', '--progress',
                        expanduser(path.rstrip('/')), dest]
                if dryrun:
                    print ' '.join(args)
                else:
                    p = subprocess.Popen(args)
                    p.wait()
            else: # Encrypt
                if 'last' not in d[k] or last(expanduser(path)) > d[k]['last']:
                    destfilename = "%s/%s" % (dest.rstrip('/'), filename)

                    if dryrun:
                        print "tar c '%s' | gpg -c > %s" % (path, destfilename)
                    else:
                        d[k]['last'] = now
                        encrypt(path, destfilename, passphrase, now, dryrun)

    return paths

# FIXME As a separate option?
def mkd(path):
    try:
        f = open(path)
        d = []
        for w in f:
            d.append(w)
        f.close()
        return d
    except IOError, e:
        print sys.stderr, e

def passwd():
    '''
    Ask for passphrase twice, making sure they're identical and not empty
    and return one of them
    '''

    # A la gpg
    p0 = getpass.getpass("Enter passphrase: ")
    p1 = getpass.getpass("Repeat passphrase: ")

    if p0 == p1 and p0 != '':
        return p0
    else:
        raise InvalidPassphraseError()

def main():
    # Arguments
    description = "Back up files and encrypt them on the fly if needs be"
    p = argparse.ArgumentParser(description=description)
    help = "file listing what is to be backed up and how"
    p.add_argument("rcfile", help=help)
    help = "perform a trial run with no changes made"
    p.add_argument("--dry-run", action='store_true', help=help)
    help = "destination backup directory"
    p.add_argument("dest", help=help)
    args = p.parse_args()

    # Load RC file
    try:
        f = open(args.rcfile, 'r')
        rc = yaml.load(f)
        f.close()
    except IOError, e:
        print >>sys.stderr, e
        return 1

    # Perform backup
    try:
        passphrase = passwd()
        paths = bkp(rc, args.dest, passphrase, args.dry_run)
        f = open(args.rcfile, 'w')
        f.write(yaml.dump(paths, default_flow_style=False))
        f.close()
    except InvalidPassphraseError, e:
        print >>sys.stderr, "Invalid passphrase"
        return 1

if __name__ == '__main__':
    sys.exit(main())
