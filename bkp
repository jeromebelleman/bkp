#! /usr/bin/env python

import sys, os, os.path
from os.path import expanduser
import subprocess, shlex
import random
import optparse
import tarfile
import getpass
import argparse
import datetime, time
import yaml

# FIXME We should be able to do a single expanduser once and for all

class InvalidPassphraseError(Exception):
    pass

def last(path):
    '''
    Return modification time of last-modified file in expanded path hierarchy
    '''

    maxtime = 0

    # FIXME Maybe checking ctime is good enough because it's always >= mtime?

    def getmaxtime(path, maxtime):
        s = os.stat(path)
        maybemax = s.st_mtime if s.st_mtime > s.st_ctime else s.st_ctime
        return maybemax if maybemax > maxtime else maxtime

    # Root directory
    maxtime = getmaxtime(path, maxtime)

    # Sub hierarchy
    for root, dirs, files in os.walk(path):
        for f in dirs + files:
            maxtime = getmaxtime(root + '/' + f, maxtime)
    return maxtime

def encrypt(path, destfilename, passphrase, now, dryrun=False):
    '''
    Back up by archiving and encrypting on the fly

    Arguments:
    - path to back up
    - destination path
    - passphrase
    - datetime when file has been encrypted and backed up
    - optionally do a dry run
    '''

    cmd = "gpg -c --passphrase-fd 0"
    if dryrun:
        print "tar c '%s' | gpg -c > %s" % (path, destfilename)
    else:
        # Open destination encrypted file
        f = open(destfilename, 'w')

        # Have gpg listen up the pipe
        args  = shlex.split(cmd)
        p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=f)

        # Seems gpg now expects a passphrase, then data down the pipe

        # Write passphrase down the pipe
        print >>p.stdin, passphrase

        # Have tar write data down the pipe
        t = tarfile.open(mode='w|', fileobj=p.stdin)
        t.add(expanduser(path))

        f.close()

def bkp(paths, dest, col, passphrase, dryrun=False):
    '''
    Perform backup

    Arguments:
    - list of paths to back up
    - destination directory
    - backup collection name
    - passphrase
    - optionally do a dry run
    '''

    now = time.mktime(datetime.datetime.now().timetuple())

    for path in paths:
        d = paths[path]
        # Assume there's an active key
        try:
            active = d['active']
        except KeyError: # So there's no active key
            active = True # Implicitely back up

        if active:
            # Assume it's to be encrypted
            try:
                destfilename = "%s/%s/%s/%s" % \
                    (dest, col, d['destination'], d['filename'])

                if not os.path.isfile(destfilename) or \
                    last(expanduser(path)) > os.stat(destfilename).st_ctime:
                    if dryrun:
                        print "tar c '%s' | gpg -c > %s" % (path, destfilename)
                    else:
                        d['last'] = now
                        encrypt(path, destfilename, passphrase, now, dryrun)
            except KeyError: # So it's not to be encrypted
                args = ['rsync', '-aq', '--delete', '--progress',
                        expanduser(path.rstrip('/')),
                        '%s/%s/%s' % (dest, col, d['destination'])
                       ]
                if dryrun:
                    print ' '.join(args)
                else:
                    p = subprocess.Popen(args)
                    p.wait()

# FIXME As a separate option?
def mkd(path):
    try:
        f = open(path)
        d = []
        for w in f:
            d.append(w)
        f.close()
        return d
    except IOError, e:
        print sys.stderr, e

def passwd():
    '''
    Ask for passphrase twice, making sure they're identical and not empty
    and return one of them
    '''

    # A la gpg
    p0 = getpass.getpass("Enter passphrase: ")
    p1 = getpass.getpass("Repeat passphrase: ")

    if p0 == p1 and p0 != '':
        return p0
    else:
        raise InvalidPassphraseError()

def main():
    # Arguments
    description = "Back up files and encrypt them on the fly if needs be"
    p = argparse.ArgumentParser(description=description)
    help = "file listing what is to be backed up and how"
    p.add_argument("rcfile", help=help)
    help = "perform a trial run with no changes made"
    p.add_argument("--dry-run", action='store_true', help=help)
    help = "destination backup directory"
    p.add_argument("dest", help=help)
    args = p.parse_args()

    # Load RC file
    try:
        f = open(args.rcfile, 'r')
        rc = yaml.load(f)
        f.close()
    except IOError, e:
        print >>sys.stderr, e
        return 1

    # Perform backup
    try:
        passphrase = passwd()
        bkp(rc, args.dest, args.rcfile.rsplit('.', 1)[0],
            passphrase, args.dry_run)
    except InvalidPassphraseError, e:
        print >>sys.stderr, "Invalid passphrase"
        return 1

if __name__ == '__main__':
    sys.exit(main())
